org 0x7C00

bits 16
global _start

_start:
    cli ; turn off interrupts
    mov si, message
    mov ah, 0x0E ; set up interrupt. 0x0E is the print char command
.loop:
    lodsb ; loads the next byte into al
    or al, al
    jz .printed ; if the char == NUL, we're done!
    int 0x10 ; VGA general interrupt
    jmp .loop ; continue

.printed:
    ; let's enable protected mode!
    jmp enable_protected

idle:
    hlt
    jmp $

enable_protected:
    ; enabling protected mode involves flipping one bit on
    ; the cr0 register (the first bit, PE, aka Protected mode Enabled)
    mov eax, cr0 ; move it into a scratch register
    or eax, 1 ; flip the bit
    mov cr0, eax ; save the modified control register
    ; what this means:
    ; - paging can be enabled
    ; 1MB --> 4GB of addressable memory
    ; 32bit (or 16bit) operand sizes (going to use 32)
    jmp protected_start

; PROTECTED MODE SECTION!
; now using 32 bit operand sizes
bits 32

protected_start:
    ; setup GDT
    lgdt [gdt_register]
    ; load empty IDT
    lidt [idt_register]

    ; temporary halt until we can call the kernel
    hlt
    jmp $

message: db "hola mundo!", 0

align 16
gdt_register:
    dw (end_gdt - gdt - 1) ; the size of the gdt (gdt limit), offset by -1
    dd gdt ; the address to the GDT itself

gdt:
    dq 0 ; null gdt entry
; the following entries were generated by tool/gengdt
    dq 0xa09a010f2c0000 ; kernel code entry
    dq 0xc092010f2c0000 ; kernel data entry
    ; dq 0xa0fa010f2c0000 ; user mode code entry, not required
    ; dq 0xc0f2010f2c0000 ; user mode data entry, not required
end_gdt:

align 16
idt_register:
    ; it's empty
    dw 0
    dd 0
    ; dw (end_idt - idt - 1) ; the size of the idt (idt limit), offset by -1 just like the gdt
    ; dd idt ; the address to the IDT

; interrupt descriptor table
; idt:
;     dq 0 ; a blank entry. this is not the NULL entry like exists in the GDT
; end_idt:

kernel_signature:
    dw 26985 ; magic number

; mbr boot signature
times 510-($-$$) db 0
dw 0xAA55